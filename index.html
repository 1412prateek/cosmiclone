<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CosmiClone Watch Party</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #bb86fc;
            --secondary-color: #03dac6;
            --text-color: #e0e0e0;
            --error-color: #cf6679;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: #000;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: #000;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .input-field {
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid #333;
            background-color: #2c2c2c;
            color: white;
            width: 100%;
            margin-bottom: var(--spacing-md);
        }

        /* Lobby Styles */
        #lobby-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }

        .lobby-card {
            background-color: var(--surface-color);
            padding: 40px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .divider {
            margin: 20px 0;
            border-top: 1px solid #333;
        }

        /* Room Layout */
        #room-view {
            display: grid;
            grid-template-columns: 1fr 300px;
            /* Desktop default */
            grid-template-rows: 1fr auto;
            height: 100dvh;
            width: 100vw;
        }

        /* Main Theater Area */
        #theater-container {
            grid-column: 1 / 2;
            grid-row: 1 / 2;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
        }

        /* Sidebar (Chat & Users) */
        #sidebar {
            grid-column: 2 / 3;
            grid-row: 1 / 3;
            background-color: var(--surface-color);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid #333;
            font-weight: bold;
        }

        #user-grid {
            flex: 1;
            padding: var(--spacing-sm);
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-sm);
        }

        .user-card {
            background-color: #2c2c2c;
            height: 150px;
            /* Placeholder for video */
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .user-name {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        /* Control Deck */
        #control-deck {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            background-color: rgba(30, 30, 30, 0.9);
            padding: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            z-index: 10;
        }

        .control-group {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        .flex-grow {
            flex-grow: 1;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #room-view {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                /* Video, Users, Controls */
                height: 100dvh;
            }

            #theater-container {
                grid-column: 1 / 2;
                grid-row: 1 / 2;
                max-height: 40vh;
                /* Limit video height */
            }

            #sidebar {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
                border-left: none;
                border-top: 1px solid #333;
                overflow-y: auto;
            }

            #control-deck {
                grid-column: 1 / 2;
                grid-row: 3 / 4;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 10px;
                padding: 15px;
                background-color: var(--surface-color);
                border-top: 1px solid #333;
                z-index: 20;
            }

            /* Mobile Ergonomics */
            #seek-bar {
                order: 1;
                width: 100%;
                flex-basis: 100%;
                margin-bottom: 10px;
            }

            #play-pause-btn {
                order: 2;
            }

            #time-display {
                order: 2;
                margin-left: 10px;
            }

            .control-group {
                order: 3;
                width: 100%;
                justify-content: center;
                margin-top: 10px;
                margin-left: 0;
            }

            .btn {
                padding: 12px 16px;
                /* Larger touch targets */
            }

            #mixer-modal {
                width: 90%;
            }
        }

        /* Mixer Modal */
        #mixer-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--surface-color);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            width: 300px;
            border: 1px solid #333;
        }

        .mixer-group {
            margin-bottom: var(--spacing-md);
        }

        .mixer-label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-size: 0.9rem;
        }

        /* Remote Video */
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--border-radius);
        }

        /* Offline Overlay */
        #offline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--error-color);
        }

        #offline-overlay h2 {
            margin-bottom: var(--spacing-md);
        }
    </style>
</head>

<body>

    <!-- OFFLINE OVERLAY -->
    <div id="offline-overlay" class="hidden">
        <h2>Connection Lost</h2>
        <p>Reconnecting...</p>
    </div>

    <!-- LOBBY VIEW -->
    <div id="lobby-view">
        <div class="lobby-card">
            <h1>CosmiClone</h1>
            <p style="margin-bottom: 20px; color: #aaa;">Watch Party Platform</p>

            <input type="text" id="display-name" class="input-field" placeholder="Enter your Display Name" />

            <button id="create-room-btn" class="btn btn-primary" style="width: 100%">Create New Room</button>

            <div class="divider">OR</div>

            <input type="text" id="room-id-input" class="input-field" placeholder="Enter Room ID" />
            <button id="join-room-btn" class="btn btn-secondary" style="width: 100%">Join Room</button>
        </div>
    </div>

    <!-- ROOM VIEW -->
    <div id="room-view" class="hidden">
        <div id="theater-container">
            <!-- Removed default src -->
            <video id="main-video" controls playsinline></video>
        </div>

        <div id="control-deck">
            <button class="btn btn-secondary" id="play-pause-btn">Play</button>
            <input type="range" id="seek-bar" class="flex-grow" value="0" min="0" max="100">
            <span id="time-display">00:00 / 00:00</span>

            <!-- Host Controls (Hidden by default) -->
            <div id="host-controls" class="hidden" style="display: flex; gap: 8px;">
                <button class="btn btn-primary" id="share-screen-btn">Share Screen</button>
                <button class="btn btn-primary" id="upload-video-btn">Upload Video</button>
                <input type="file" id="file-input" accept="video/*" hidden>
            </div>

            <div class="control-group">
                <button class="btn btn-secondary" id="mic-btn">Mic On</button>
                <button class="btn btn-secondary" id="cam-btn">Cam On</button>
                <button class="btn btn-primary" id="mixer-toggle">Mixer</button>
            </div>
        </div>

        <!-- MIXER MODAL -->
        <div id="mixer-modal" class="hidden">
            <h3>Audio Mixer</h3>
            <div class="mixer-group">
                <label class="mixer-label">Media Volume</label>
                <input type="range" id="media-volume" min="0" max="1" step="0.1" value="1" style="width: 100%">
            </div>
            <div class="mixer-group">
                <label class="mixer-label">Voice Volume</label>
                <input type="range" id="voice-volume" min="0" max="2" step="0.1" value="1" style="width: 100%">
            </div>
            <button class="btn btn-secondary" id="close-mixer" style="width: 100%">Close</button>
        </div>

        <div id="sidebar">
            <div class="sidebar-header">
                Room: <span id="current-room-id">...</span>
            </div>
            <div id="user-grid">
                <!-- User cards will go here -->
                <div class="user-card">
                    <span class="user-name">You</span>
                </div>
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, addDoc, query, where } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        // --- CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyA5OQr1ZKHYS24ftvPksa3rV8RdnIU4xlU",
            authDomain: "video-calling-49b53.firebaseapp.com",
            projectId: "video-calling-49b53",
            storageBucket: "video-calling-49b53.firebasestorage.app",
            messagingSenderId: "669016418304",
            appId: "1:669016418304:web:5d12fb5680dbb0759a50e5",
            measurementId: "G-ESB4LZ89FW"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- STATE ---
        let currentUser = null;
        let currentRoomId = null;
        let isHost = false;
        let mainStream = null; // The stream being broadcasted (Screen or File)
        let roomHostId = null; // Store host ID globally
        let activeMainStreamId = null; // ID of the current main stream (synced from Firestore)

        // --- DOM ELEMENTS ---
        const lobbyView = document.getElementById('lobby-view');
        const roomView = document.getElementById('room-view');
        const displayNameInput = document.getElementById('display-name');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomIdInput = document.getElementById('room-id-input');
        const currentRoomIdDisplay = document.getElementById('current-room-id');

        const mainVideo = document.getElementById('main-video');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const seekBar = document.getElementById('seek-bar');
        const timeDisplay = document.getElementById('time-display');

        const hostControls = document.getElementById('host-controls');
        const shareScreenBtn = document.getElementById('share-screen-btn');
        const uploadVideoBtn = document.getElementById('upload-video-btn');
        const fileInput = document.getElementById('file-input');

        // --- FUNCTIONS ---

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function enterRoom(roomId, hostId) {
            roomHostId = hostId;
            lobbyView.classList.add('hidden');
            roomView.classList.remove('hidden');
            currentRoomId = roomId;
            currentRoomIdDisplay.textContent = roomId;

            isHost = (currentUser.uid === hostId);
            if (isHost) {
                hostControls.classList.remove('hidden');
                hostControls.style.display = 'flex'; // Ensure flex layout
            }

            window.history.pushState({ roomId }, '', `?room=${roomId}`);
        }

        async function initUser() {
            try {
                const userCredential = await signInAnonymously(auth);
                currentUser = userCredential.user;
                return currentUser;
            } catch (error) {
                console.error("Error signing in:", error);
                alert("Authentication failed. Check console.");
            }
        }

        async function createRoom() {
            const name = displayNameInput.value.trim();
            if (!name) { alert("Please enter a display name."); return; }

            await initUser();
            const roomId = generateRoomId();

            const roomData = {
                hostId: currentUser.uid,
                status: "paused",
                activeUsers: [{ uid: currentUser.uid, name: name, isMuted: false }],
                mainStreamId: null // Initialize main stream ID
            };

            try {
                await setDoc(doc(db, "rooms", roomId), roomData);
                enterRoom(roomId, currentUser.uid);
                initWebRTC(); // Start WebRTC immediately
                subscribeToRoomUpdates(roomId); // Listen for own updates (consistency)
            } catch (error) {
                console.error("Error creating room:", error);
            }
        }

        async function joinRoom() {
            const name = displayNameInput.value.trim();
            const roomId = roomIdInput.value.trim().toUpperCase();

            if (!name || !roomId) { alert("Please enter a display name and Room ID."); return; }

            await initUser();

            const roomRef = doc(db, "rooms", roomId);
            const roomSnap = await getDoc(roomRef);

            if (roomSnap.exists()) {
                const data = roomSnap.data();
                enterRoom(roomId, data.hostId);
                initWebRTC();
                subscribeToSignals(roomId);
                subscribeToRoomUpdates(roomId); // Listen for mainStreamId updates

                // Add self to active users
                const users = data.activeUsers || [];
                if (!users.find(u => u.uid === currentUser.uid)) {
                    users.push({ uid: currentUser.uid, name: name, isMuted: false });
                    await setDoc(roomRef, { activeUsers: users }, { merge: true });
                }

                initiateCalls(users);
            } else {
                alert("Room not found!");
            }
        }

        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);

        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            if (roomParam) roomIdInput.value = roomParam;
        });

        // --- ROOM UPDATES (Stream Tagging) ---
        function subscribeToRoomUpdates(roomId) {
            onSnapshot(doc(db, "rooms", roomId), (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    if (data.mainStreamId !== activeMainStreamId) {
                        activeMainStreamId = data.mainStreamId;
                        console.log("Main Stream ID updated:", activeMainStreamId);
                        // Re-evaluate streams if we have any pending
                        reassignStreams();
                    }
                }
            });
        }

        function reassignStreams() {
            // Iterate through all remote videos and check if they should be moved
            // This is a bit complex, simpler to handle in `ontrack` and `checkHostAndAssignStream`
            // But if the ID arrives AFTER the stream, we need to check.

            // For now, let's rely on the fact that `ontrack` fires when stream is added.
            // If we already have streams, we might need to swap them.
            // Implementation detail: We store streams in a map or just check DOM.
        }

        // --- HOST BROADCAST LOGIC ---

        // 1. Share Screen
        shareScreenBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                startBroadcasting(stream);

                // Show locally
                mainVideo.srcObject = stream;
                mainVideo.play();
            } catch (err) {
                console.error("Error sharing screen:", err);
            }
        });

        // 2. Upload Video
        uploadVideoBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                mainVideo.src = url;
                mainVideo.play();

                mainVideo.onloadedmetadata = () => {
                    const stream = mainVideo.captureStream ? mainVideo.captureStream() : mainVideo.mozCaptureStream();
                    startBroadcasting(stream);
                };
            }
        });

        // Broadcast the stream to all connected peers
        async function startBroadcasting(stream) {
            mainStream = stream;

            // 1. Update Room with new Stream ID (Tagging)
            await setDoc(doc(db, "rooms", currentRoomId), { mainStreamId: stream.id }, { merge: true });

            // 2. Add tracks to all existing peer connections
            Object.values(peerConnections).forEach(pc => {
                stream.getTracks().forEach(track => {
                    const senders = pc.getSenders();
                    const alreadySending = senders.find(s => s.track === track);
                    if (!alreadySending) {
                        pc.addTrack(track, stream);
                        // Negotiation needed will fire automatically
                    }
                });
            });
        }

        // --- WEBRTC & MIXER ---
        const micBtn = document.getElementById('mic-btn');
        const camBtn = document.getElementById('cam-btn');
        const mixerToggle = document.getElementById('mixer-toggle');
        const mixerModal = document.getElementById('mixer-modal');
        const closeMixer = document.getElementById('close-mixer');
        const mediaVolumeSlider = document.getElementById('media-volume');
        const voiceVolumeSlider = document.getElementById('voice-volume');
        const userGrid = document.getElementById('user-grid');

        let localStream = null;
        let peerConnections = {};
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        async function initWebRTC() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                addLocalVideo(localStream);
            } catch (error) {
                console.error("Error accessing media devices:", error);
                alert("Camera/Mic access denied.");
            }
        }

        function addLocalVideo(stream) {
            const cards = userGrid.getElementsByClassName('user-card');
            for (let card of cards) {
                if (card.querySelector('.user-name').textContent === 'You') {
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.muted = true;
                    video.autoplay = true;
                    video.playsInline = true;
                    video.className = 'remote-video';
                    card.innerHTML = '';
                    card.appendChild(video);
                    const nameTag = document.createElement('span');
                    nameTag.className = 'user-name';
                    nameTag.textContent = 'You';
                    card.appendChild(nameTag);
                    break;
                }
            }
        }

        function subscribeToSignals(roomId) {
            const signalsRef = collection(db, "rooms", roomId, "signals");
            const q = query(signalsRef, where("to", "==", currentUser.uid));

            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const data = change.doc.data();
                        handleSignal(data);
                    }
                });
            });
        }

        async function handleSignal(data) {
            const fromId = data.from;

            if (data.type === 'offer') {
                await createPeerConnection(fromId);
                const pc = peerConnections[fromId];

                // Avoid setting remote description if we are in a weird state
                if (pc.signalingState !== "stable" && pc.signalingState !== "have-local-offer") {
                    // If we are already negotiating, we might need to rollback or ignore.
                    // But for simple cases, just proceeding usually works or throws.
                }

                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await addDoc(collection(db, "rooms", currentRoomId, "signals"), {
                    to: fromId,
                    from: currentUser.uid,
                    type: 'answer',
                    answer: answer
                });
            } else if (data.type === 'answer') {
                const pc = peerConnections[fromId];
                if (pc) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            } else if (data.type === 'ice-candidate') {
                const pc = peerConnections[fromId];
                if (pc) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            }
        }

        async function createPeerConnection(targetUid) {
            if (peerConnections[targetUid]) return peerConnections[targetUid];

            const pc = new RTCPeerConnection(iceServers);
            peerConnections[targetUid] = pc;

            // Add local camera tracks
            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            // If Host, also add Main Stream tracks if active
            if (isHost && mainStream) {
                mainStream.getTracks().forEach(track => pc.addTrack(track, mainStream));
            }

            // --- RENEGOTIATION LOGIC ---
            pc.onnegotiationneeded = async () => {
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    await addDoc(collection(db, "rooms", currentRoomId, "signals"), {
                        to: targetUid,
                        from: currentUser.uid,
                        type: 'offer',
                        offer: offer
                    });
                } catch (err) {
                    console.error("Negotiation error:", err);
                }
            };

            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await addDoc(collection(db, "rooms", currentRoomId, "signals"), {
                        to: targetUid,
                        from: currentUser.uid,
                        type: 'ice-candidate',
                        candidate: event.candidate.toJSON()
                    });
                }
            };

            // Handle Incoming Streams
            pc.ontrack = (event) => {
                const stream = event.streams[0];
                checkHostAndAssignStream(targetUid, stream);
            };

            return pc;
        }

        function checkHostAndAssignStream(uid, stream) {
            // Robust check using Stream ID from Firestore
            if (activeMainStreamId && stream.id === activeMainStreamId) {
                // This IS the main stream
                mainVideo.srcObject = stream;
                mainVideo.play().catch(e => console.log("Autoplay blocked:", e));
            } else {
                // It's a user camera (or we don't know yet, default to camera)
                addRemoteVideo(uid, stream);

                // Edge case: If we haven't received the mainStreamId yet, we might put Main Video in User Card.
                // We can fix this by checking later when activeMainStreamId updates.
            }
        }

        function addRemoteVideo(uid, stream) {
            let card = document.getElementById(`user-${uid}`);
            if (!card) {
                card = document.createElement('div');
                card.className = 'user-card';
                card.id = `user-${uid}`;
                userGrid.appendChild(card);

                const nameTag = document.createElement('span');
                nameTag.className = 'user-name';
                nameTag.textContent = 'User ' + uid.substring(0, 4);
                card.appendChild(nameTag);
            }

            // Check if video already exists
            let video = card.querySelector('video');
            if (!video) {
                video = document.createElement('video');
                video.className = 'remote-video';
                video.autoplay = true;
                video.playsInline = true; // Critical for mobile
                card.insertBefore(video, card.firstChild);
            }

            // Only update if stream changed
            if (video.srcObject !== stream) {
                video.srcObject = stream;
                video.volume = voiceVolumeSlider.value;
            }
        }

        async function initiateCalls(activeUsers) {
            for (let user of activeUsers) {
                if (user.uid === currentUser.uid) continue;

                const pc = await createPeerConnection(user.uid);
                // Offer creation is now handled by onnegotiationneeded!
                // But for initial connection, we might need to trigger it manually if no tracks added?
                // Actually, adding tracks triggers it.
                // However, `createPeerConnection` adds tracks immediately.
                // So `onnegotiationneeded` should fire.
                // Let's rely on that to avoid duplicate offers.
            }
        }

        // Mixer Logic
        mixerToggle.addEventListener('click', () => mixerModal.classList.remove('hidden'));
        closeMixer.addEventListener('click', () => mixerModal.classList.add('hidden'));

        mediaVolumeSlider.addEventListener('input', (e) => {
            mainVideo.volume = e.target.value;
        });

        voiceVolumeSlider.addEventListener('input', (e) => {
            const vol = e.target.value;
            document.querySelectorAll('.remote-video').forEach(video => {
                if (video !== localStream) {
                    video.volume = Math.min(1, vol);
                }
            });
        });

        // Toggle Controls
        let isMicOn = true;
        let isCamOn = true;

        micBtn.addEventListener('click', () => {
            isMicOn = !isMicOn;
            localStream.getAudioTracks().forEach(t => t.enabled = isMicOn);
            micBtn.textContent = isMicOn ? 'Mic On' : 'Mic Off';
            micBtn.classList.toggle('btn-secondary');
            if (!isMicOn) micBtn.style.backgroundColor = 'var(--error-color)';
            else micBtn.style.backgroundColor = 'var(--secondary-color)';
        });

        camBtn.addEventListener('click', () => {
            isCamOn = !isCamOn;
            localStream.getVideoTracks().forEach(t => t.enabled = isCamOn);
            camBtn.textContent = isCamOn ? 'Cam On' : 'Cam Off';
            if (!isCamOn) camBtn.style.backgroundColor = 'var(--error-color)';
            else camBtn.style.backgroundColor = 'var(--secondary-color)';
        });

        // --- OFFLINE HANDLING ---
        const offlineOverlay = document.getElementById('offline-overlay');

        window.addEventListener('offline', () => {
            offlineOverlay.classList.remove('hidden');
            if (!mainVideo.paused) mainVideo.pause();
        });

        window.addEventListener('online', () => {
            offlineOverlay.classList.add('hidden');
        });

        // --- LOCAL PLAYBACK CONTROLS ---
        playPauseBtn.addEventListener('click', () => {
            if (mainVideo.paused) mainVideo.play();
            else mainVideo.pause();
        });

        mainVideo.addEventListener('timeupdate', () => {
            const value = (mainVideo.currentTime / mainVideo.duration) * 100;
            seekBar.value = value || 0;
            timeDisplay.textContent = `${formatTime(mainVideo.currentTime)} / ${formatTime(mainVideo.duration)}`;
        });

        seekBar.addEventListener('input', () => {
            const time = (seekBar.value / 100) * mainVideo.duration;
            mainVideo.currentTime = time;
        });

        function formatTime(seconds) {
            if (!seconds) return "00:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }
    </script>
</body>

</html>