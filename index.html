<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CosmiClone Watch Party</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #bb86fc;
            --secondary-color: #03dac6;
            --text-color: #e0e0e0;
            --error-color: #cf6679;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: #000;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: #000;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .input-field {
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid #333;
            background-color: #2c2c2c;
            color: white;
            width: 100%;
            margin-bottom: var(--spacing-md);
        }

        /* Lobby Styles */
        #lobby-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }

        .lobby-card {
            background-color: var(--surface-color);
            padding: 40px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .divider {
            margin: 20px 0;
            border-top: 1px solid #333;
        }

        /* Room Layout */
        #room-view {
            display: grid;
            grid-template-columns: 1fr 300px;
            /* Desktop default */
            grid-template-rows: 1fr auto;
            height: 100vh;
            width: 100vw;
        }

        /* Main Theater Area */
        #theater-container {
            grid-column: 1 / 2;
            grid-row: 1 / 2;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
        }

        /* Sidebar (Chat & Users) */
        #sidebar {
            grid-column: 2 / 3;
            grid-row: 1 / 3;
            background-color: var(--surface-color);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid #333;
            font-weight: bold;
        }

        #user-grid {
            flex: 1;
            padding: var(--spacing-sm);
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-sm);
        }

        .user-card {
            background-color: #2c2c2c;
            height: 150px;
            /* Placeholder for video */
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .user-name {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        /* Control Deck */
        #control-deck {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            background-color: rgba(30, 30, 30, 0.9);
            padding: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            z-index: 10;
        }

        .control-group {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        .flex-grow {
            flex-grow: 1;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #room-view {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                /* Video, Users, Controls */
                height: 100vh;
            }

            #theater-container {
                grid-column: 1 / 2;
                grid-row: 1 / 2;
                max-height: 40vh;
                /* Limit video height */
            }

            #sidebar {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
                border-left: none;
                border-top: 1px solid #333;
                overflow-y: auto;
            }

            #control-deck {
                grid-column: 1 / 2;
                grid-row: 3 / 4;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 10px;
                padding: 15px;
                background-color: var(--surface-color);
                border-top: 1px solid #333;
                z-index: 20;
            }

            /* Mobile Ergonomics */
            #seek-bar {
                order: 1;
                width: 100%;
                flex-basis: 100%;
                margin-bottom: 5px;
            }

            #play-pause-btn {
                order: 2;
            }

            #time-display {
                order: 2;
            }

            .control-group {
                order: 2;
                margin-left: auto;
                /* Push to right */
            }

            .btn {
                padding: 12px 16px;
                /* Larger touch targets */
            }

            #mixer-modal {
                width: 90%;
            }
        }

        /* Mixer Modal */
        #mixer-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--surface-color);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            width: 300px;
            border: 1px solid #333;
        }

        .mixer-group {
            margin-bottom: var(--spacing-md);
        }

        .mixer-label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-size: 0.9rem;
        }

        /* Remote Video */
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--border-radius);
        }

        /* Offline Overlay */
        #offline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--error-color);
        }

        #offline-overlay h2 {
            margin-bottom: var(--spacing-md);
        }
    </style>
</head>

<body>

    <!-- OFFLINE OVERLAY -->
    <div id="offline-overlay" class="hidden">
        <h2>Connection Lost</h2>
        <p>Reconnecting...</p>
    </div>

    <!-- LOBBY VIEW -->
    <div id="lobby-view">
        <div class="lobby-card">
            <h1>CosmiClone</h1>
            <p style="margin-bottom: 20px; color: #aaa;">Watch Party Platform</p>

            <input type="text" id="display-name" class="input-field" placeholder="Enter your Display Name" />

            <button id="create-room-btn" class="btn btn-primary" style="width: 100%">Create New Room</button>

            <div class="divider">OR</div>

            <input type="text" id="room-id-input" class="input-field" placeholder="Enter Room ID" />
            <button id="join-room-btn" class="btn btn-secondary" style="width: 100%">Join Room</button>
        </div>
    </div>

    <!-- ROOM VIEW -->
    <div id="room-view" class="hidden">
        <div id="theater-container">
            <video id="main-video" controls>
                <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
                    type="video/mp4">
                Your browser does not support the video tag.
            </video>
        </div>

        <div id="control-deck">
            <button class="btn btn-secondary" id="play-pause-btn">Play</button>
            <input type="range" id="seek-bar" class="flex-grow" value="0" min="0" max="100">
            <span id="time-display">00:00 / 00:00</span>
            <div class="control-group">
                <button class="btn btn-secondary" id="mic-btn">Mic On</button>
                <button class="btn btn-secondary" id="cam-btn">Cam On</button>
                <button class="btn btn-primary" id="mixer-toggle">Mixer</button>
            </div>
        </div>

        <!-- MIXER MODAL -->
        <div id="mixer-modal" class="hidden">
            <h3>Audio Mixer</h3>
            <div class="mixer-group">
                <label class="mixer-label">Media Volume</label>
                <input type="range" id="media-volume" min="0" max="1" step="0.1" value="1" style="width: 100%">
            </div>
            <div class="mixer-group">
                <label class="mixer-label">Voice Volume</label>
                <input type="range" id="voice-volume" min="0" max="2" step="0.1" value="1" style="width: 100%">
            </div>
            <button class="btn btn-secondary" id="close-mixer" style="width: 100%">Close</button>
        </div>

        <div id="sidebar">
            <div class="sidebar-header">
                Room: <span id="current-room-id">...</span>
            </div>
            <div id="user-grid">
                <!-- User cards will go here -->
                <div class="user-card">
                    <span class="user-name">You</span>
                </div>
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, addDoc, query, where } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        // --- CONFIGURATION ---
        // Replace with your actual Firebase project config
        const firebaseConfig = {
            apiKey: "AIzaSyA5OQr1ZKHYS24ftvPksa3rV8RdnIU4xlU",
            authDomain: "video-calling-49b53.firebaseapp.com",
            projectId: "video-calling-49b53",
            storageBucket: "video-calling-49b53.firebasestorage.app",
            messagingSenderId: "669016418304",
            appId: "1:669016418304:web:5d12fb5680dbb0759a50e5",
            measurementId: "G-ESB4LZ89FW"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- STATE ---
        let currentUser = null;
        let currentRoomId = null;

        // --- DOM ELEMENTS ---
        const lobbyView = document.getElementById('lobby-view');
        const roomView = document.getElementById('room-view');
        const displayNameInput = document.getElementById('display-name');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomIdInput = document.getElementById('room-id-input');
        const currentRoomIdDisplay = document.getElementById('current-room-id');

        // --- FUNCTIONS ---

        // Generate a random 6-character Room ID
        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        // Switch to Room View
        function enterRoom(roomId) {
            lobbyView.classList.add('hidden');
            roomView.classList.remove('hidden');
            currentRoomId = roomId;
            currentRoomIdDisplay.textContent = roomId;

            // Update URL for easy sharing (optional, doesn't reload)
            window.history.pushState({ roomId }, '', `?room=${roomId}`);
        }

        // Initialize User
        async function initUser() {
            try {
                const userCredential = await signInAnonymously(auth);
                currentUser = userCredential.user;
                return currentUser;
            } catch (error) {
                console.error("Error signing in:", error);
                alert("Authentication failed. Check console.");
            }
        }

        // Create Room Logic
        async function createRoom() {
            const name = displayNameInput.value.trim();
            if (!name) {
                alert("Please enter a display name.");
                return;
            }

            await initUser();
            const roomId = generateRoomId();

            // Initial Room State (per PRD Schema)
            const roomData = {
                hostId: currentUser.uid,
                videoUrl: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4",
                status: "paused",
                currentTime: 0,
                lastUpdated: Date.now(),
                activeUsers: [
                    {
                        uid: currentUser.uid,
                        name: name,
                        isMuted: false
                    }
                ]
            };

            try {
                await setDoc(doc(db, "rooms", roomId), roomData);
                enterRoom(roomId);
            } catch (error) {
                console.error("Error creating room:", error);
                alert("Failed to create room. Check console/config.");
            }
        }

        // Join Room Logic
        async function joinRoom() {
            const name = displayNameInput.value.trim();
            const roomId = roomIdInput.value.trim().toUpperCase();

            if (!name || !roomId) {
                alert("Please enter a display name and Room ID.");
                return;
            }

            await initUser();

            const roomRef = doc(db, "rooms", roomId);
            const roomSnap = await getDoc(roomRef);

            if (roomSnap.exists()) {
                enterRoom(roomId);
            } else {
                alert("Room not found!");
            }
        }

        // --- EVENT LISTENERS ---
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);

        // Check URL params for room ID on load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            if (roomParam) {
                roomIdInput.value = roomParam;
            }
        });

        // --- SYNC ENGINE ---
        const mainVideo = document.getElementById('main-video');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const seekBar = document.getElementById('seek-bar');
        const timeDisplay = document.getElementById('time-display');

        let isRemoteUpdate = false; // Flag to prevent infinite loops
        let unsubscribeRoom = null;

        // Update Room State in Firestore
        async function updateRoomState(data) {
            if (!currentRoomId) return;
            try {
                // Merge with existing data, always update lastUpdated
                await setDoc(doc(db, "rooms", currentRoomId), {
                    ...data,
                    lastUpdated: Date.now()
                }, { merge: true });
            } catch (error) {
                console.error("Error updating room state:", error);
            }
        }

        // Subscribe to Room Updates
        function subscribeToRoom(roomId) {
            if (unsubscribeRoom) unsubscribeRoom();

            unsubscribeRoom = onSnapshot(doc(db, "rooms", roomId), (doc) => {
                if (!doc.exists()) return;
                const data = doc.data();
                handleRemoteUpdate(data);
            });
        }

        // Handle Remote Updates (The Core Sync Logic)
        function handleRemoteUpdate(data) {
            // 1. Sync Play/Pause Status
            if (data.status === 'playing' && mainVideo.paused) {
                isRemoteUpdate = true;
                mainVideo.play().catch(e => console.log("Autoplay blocked:", e));
            } else if (data.status === 'paused' && !mainVideo.paused) {
                isRemoteUpdate = true;
                mainVideo.pause();
            }

            // 2. Sync Time (Drift Correction)
            // Only sync time if the difference is significant (> 2 seconds) to avoid stuttering
            const timeDiff = Math.abs(mainVideo.currentTime - data.currentTime);
            if (timeDiff > 2) {
                isRemoteUpdate = true;
                mainVideo.currentTime = data.currentTime;
            }

            // Update UI
            updateControlsUI();
        }

        // Local Video Event Listeners
        mainVideo.addEventListener('play', () => {
            if (isRemoteUpdate) { isRemoteUpdate = false; return; }
            updateRoomState({ status: 'playing', currentTime: mainVideo.currentTime });
            updateControlsUI();
        });

        mainVideo.addEventListener('pause', () => {
            if (isRemoteUpdate) { isRemoteUpdate = false; return; }
            updateRoomState({ status: 'paused', currentTime: mainVideo.currentTime });
            updateControlsUI();
        });

        mainVideo.addEventListener('seeked', () => {
            if (isRemoteUpdate) { isRemoteUpdate = false; return; }
            updateRoomState({ currentTime: mainVideo.currentTime });
        });

        // UI Updates
        function updateControlsUI() {
            playPauseBtn.textContent = mainVideo.paused ? 'Play' : 'Pause';
        }

        mainVideo.addEventListener('timeupdate', () => {
            const value = (mainVideo.currentTime / mainVideo.duration) * 100;
            seekBar.value = value || 0;

            // Format Time
            const current = formatTime(mainVideo.currentTime);
            const total = formatTime(mainVideo.duration);
            timeDisplay.textContent = `${current} / ${total}`;
        });

        seekBar.addEventListener('input', () => {
            const time = (seekBar.value / 100) * mainVideo.duration;
            mainVideo.currentTime = time;
        });

        playPauseBtn.addEventListener('click', () => {
            if (mainVideo.paused) mainVideo.play();
            else mainVideo.pause();
        });

        function formatTime(seconds) {
            if (!seconds) return "00:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // --- WEBRTC & MIXER ---
        const micBtn = document.getElementById('mic-btn');
        const camBtn = document.getElementById('cam-btn');
        const mixerToggle = document.getElementById('mixer-toggle');
        const mixerModal = document.getElementById('mixer-modal');
        const closeMixer = document.getElementById('close-mixer');
        const mediaVolumeSlider = document.getElementById('media-volume');
        const voiceVolumeSlider = document.getElementById('voice-volume');
        const userGrid = document.getElementById('user-grid');

        let localStream = null;
        let peerConnections = {}; // uid -> RTCPeerConnection
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // Initialize WebRTC
        async function initWebRTC() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                addLocalVideo(localStream);
            } catch (error) {
                console.error("Error accessing media devices:", error);
                alert("Camera/Mic access denied. You won't be able to join the chat.");
            }
        }

        function addLocalVideo(stream) {
            // Find "You" card and replace placeholder
            const cards = userGrid.getElementsByClassName('user-card');
            for (let card of cards) {
                if (card.querySelector('.user-name').textContent === 'You') {
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.muted = true; // Mute local video to prevent feedback
                    video.autoplay = true;
                    video.playsInline = true;
                    video.className = 'remote-video'; // Reuse class
                    card.innerHTML = ''; // Clear placeholder
                    card.appendChild(video);
                    const nameTag = document.createElement('span');
                    nameTag.className = 'user-name';
                    nameTag.textContent = 'You';
                    card.appendChild(nameTag);
                    break;
                }
            }
        }

        // Signaling: Subscribe to messages
        function subscribeToSignals(roomId) {
            const signalsRef = collection(db, "rooms", roomId, "signals");
            // Listen for signals where 'to' == currentUser.uid
            const q = query(signalsRef, where("to", "==", currentUser.uid));

            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const data = change.doc.data();
                        handleSignal(data);
                    }
                });
            });
        }

        async function handleSignal(data) {
            const fromId = data.from;

            if (data.type === 'offer') {
                await createPeerConnection(fromId);
                const pc = peerConnections[fromId];
                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await addDoc(collection(db, "rooms", currentRoomId, "signals"), {
                    to: fromId,
                    from: currentUser.uid,
                    type: 'answer',
                    answer: answer
                });
            } else if (data.type === 'answer') {
                const pc = peerConnections[fromId];
                if (pc) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            } else if (data.type === 'ice-candidate') {
                const pc = peerConnections[fromId];
                if (pc) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            }
        }

        // Create Peer Connection
        async function createPeerConnection(targetUid) {
            if (peerConnections[targetUid]) return peerConnections[targetUid];

            const pc = new RTCPeerConnection(iceServers);
            peerConnections[targetUid] = pc;

            // Add local tracks
            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            // Handle ICE Candidates
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await addDoc(collection(db, "rooms", currentRoomId, "signals"), {
                        to: targetUid,
                        from: currentUser.uid,
                        type: 'ice-candidate',
                        candidate: event.candidate.toJSON()
                    });
                }
            };

            // Handle Remote Stream
            pc.ontrack = (event) => {
                const stream = event.streams[0];
                addRemoteVideo(targetUid, stream);
            };

            return pc;
        }

        function addRemoteVideo(uid, stream) {
            let card = document.getElementById(`user-${uid}`);
            if (!card) {
                card = document.createElement('div');
                card.className = 'user-card';
                card.id = `user-${uid}`;
                userGrid.appendChild(card);

                const nameTag = document.createElement('span');
                nameTag.className = 'user-name';
                nameTag.textContent = 'User ' + uid.substring(0, 4);
                card.appendChild(nameTag);
            }

            // Check if video already exists
            if (!card.querySelector('video')) {
                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.className = 'remote-video';
                // Apply current voice volume
                video.volume = voiceVolumeSlider.value;
                card.insertBefore(video, card.firstChild);
            }
        }

        // Initiate Call (Called when joining)
        async function initiateCalls(activeUsers) {
            for (let user of activeUsers) {
                if (user.uid === currentUser.uid) continue;

                const pc = await createPeerConnection(user.uid);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                await addDoc(collection(db, "rooms", currentRoomId, "signals"), {
                    to: user.uid,
                    from: currentUser.uid,
                    type: 'offer',
                    offer: offer
                });
            }
        }

        // Mixer Logic
        mixerToggle.addEventListener('click', () => mixerModal.classList.remove('hidden'));
        closeMixer.addEventListener('click', () => mixerModal.classList.add('hidden'));

        mediaVolumeSlider.addEventListener('input', (e) => {
            mainVideo.volume = e.target.value;
        });

        voiceVolumeSlider.addEventListener('input', (e) => {
            const vol = e.target.value;
            // Update all remote videos
            document.querySelectorAll('.remote-video').forEach(video => {
                if (video !== localStream) { // Don't change local video (it's muted anyway)
                    video.volume = Math.min(1, vol); // HTML video volume is 0-1
                }
            });
        });

        // Toggle Controls
        let isMicOn = true;
        let isCamOn = true;

        micBtn.addEventListener('click', () => {
            isMicOn = !isMicOn;
            localStream.getAudioTracks().forEach(t => t.enabled = isMicOn);
            micBtn.textContent = isMicOn ? 'Mic On' : 'Mic Off';
            micBtn.classList.toggle('btn-secondary');
            if (!isMicOn) micBtn.style.backgroundColor = 'var(--error-color)';
            else micBtn.style.backgroundColor = 'var(--secondary-color)';
        });

        camBtn.addEventListener('click', () => {
            isCamOn = !isCamOn;
            localStream.getVideoTracks().forEach(t => t.enabled = isCamOn);
            camBtn.textContent = isCamOn ? 'Cam On' : 'Cam Off';
            if (!isCamOn) camBtn.style.backgroundColor = 'var(--error-color)';
            else camBtn.style.backgroundColor = 'var(--secondary-color)';
        });

        // Update enterRoom to init WebRTC
        const prevEnterRoom = enterRoom;
        enterRoom = async function (roomId) {
            prevEnterRoom(roomId);
            await initWebRTC();
            subscribeToSignals(roomId);

            // Fetch active users to initiate calls
            const roomSnap = await getDoc(doc(db, "rooms", roomId));
            if (roomSnap.exists()) {
                const users = roomSnap.data().activeUsers || [];
                initiateCalls(users);
            }
        };

        // --- OFFLINE HANDLING ---
        const offlineOverlay = document.getElementById('offline-overlay');

        window.addEventListener('offline', () => {
            offlineOverlay.classList.remove('hidden');
            if (!mainVideo.paused) mainVideo.pause();
        });

        window.addEventListener('online', () => {
            offlineOverlay.classList.add('hidden');
        });
    </script>
</body>

</html>